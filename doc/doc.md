## Sledgehammer

for 1-4 players

sledgehammer is a multiplayer single-screen maze shooter with a simple gimmick: a whole bunch of enemies on screen fighting each other as much as they fight you

it's pretty much a direct clone of crossroads, an old c64 game. it's got online multiplayer, because it seems relatively easy, idk.

the first playable version of sledgehammer looks something like:

- there's one simple maze level
- one enemy type placed in the maze (randomly?), ideally with some level of pathfinding/player seeking
- players can shoot at enemies

my hope is that this will be relatively easy to do as an online game because, while it is real time, there's no physics to worry about. the hardest part will probably be having a whole bunch of enemies moving in sync. this might be handled by doing the dumb thing first (sending enemy position updates ~20 times a second).

i might try using webrtc/peer to peer connections (as described in https://dev.to/rynobax_7/creating-a-multiplayer-game-with-webrtc). this will probably work as one player being the host, while the other players are all clients of that host, rather than doing any sort of mesh thing. does mean if the host dies everyone loses connection, so would be good to have state be serializable from the start so if the host reconnects the game state can be recovered, or something like that

there's gotta be some kinda lobby server, which connects players together. this will take the signal generated by simple-peer on the host, stick it on a server associated with a shortened, unique room code (this could be in like a single redis instance). for starting out, can just copy-paste the signal generated by simple-peer.

once a player connects to the host, the host should send the maze, plus a snapshot of current enemy, player, bullet, etc states. then it should send another snapshot like 20 times a second or something. this will probably be good enough for starting out, i think

the host and clients will need two pretty radically different sets of game loop logic, but my hope is that the render logic will be kept the same in both, just passing in the current game state as computed either on the host or from the received game state

state tree, theoretically

- game
  - level
    - tiles[] (2d array that gets rendered once and cached)
    - power ups? items?
  - players[]
    - location (x, y)
    - facing direction (north/south/east/west)
      - this could be calculated based on previous position and current position, if using prevState and curState or something
    - id/name/color
    - time of last shot (prevent infinite bullet spam)
  - bullets[]
    - location
    - facing direction (? may matter depending how bullets are rendered)
    - player (or enemy?) associated w/
  - enemies[]
    - type
    - location
    - facing direction
    - [other enemy behavior i guess]

host game loop, i guess

- process incoming inputs (including host's)
  - move players
  - fire bullets
- run game logic
  - move bullets
  - move enemies
  - resolve collisions
- (1/3) send out update message
- render

it'll be important to protect against weird edge cases when the host receives messages that are potentially from players who are out of sync:

```
// check to make player isn't dead when a move or shoot message is received
if message.type == move and message.sender.state != dead:
```

it's possible the render loop can be 60fps while the game loop is 20 tick, but i have no idea what this would actually help with, considering any animation-update stuff would probably not be handled inside the render loop? or maybe it would?

steps to make game

1. create peer to peer connection thing i can test in two browser windows
2. send keyboard change events from client to host
3. host does things
4. render things...

### resources

- https://github.com/feross/simple-peer